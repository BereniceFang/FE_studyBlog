# Understanding ECMAScript 6笔记


## 块级变量

* `var`声明及提升
    * `var`声明的变量会被提升到函数的顶部, 如果在函数外声明的就是全局作用域
* 块级声明
    * 块级声明指在给定作用域之外无法访问的变量, 一般被创建于函数中或者块中
* `let`声明
    * 语法与`var`相同, 不过`let`可以将变量的作用域限制在当前块级
    * `let`不会被提升到顶部, 所以要在块级开头声明
* 无声明重载
    * 一个标识符在一个作用域中已被定义, 在这个作用域内使用let再次声明该标识符会导致抛出错误
    * 如果在这个作用域的子作用域中, 由let声明一个已存在的标识符, 就不会抛出错误
* 常量声明
    * 用`const`声明的变量会被视为常量, 值一旦设定就不能再变,所以每个const变量必须在声明时初始化
    * `const`是块级声明, 而且声明语句不会被提升至块级顶部
    * 当试图声明一个在本作用域中已被定义的标识符时, `const`声明也会抛出错误
    * 无论是在严格模式还是非严格模式下, 对已定义的变量进行赋值都会抛出错误
* `const`声明对象
    * `const`阻止绑定的修改, 而不阻止绑定的值的修改, 所以用`const`声明的对象可以修改其属性和方法
    * 有的浏览器实现的`const`是之前的版本, 可能与预期行为不同, 要注意!
* 临时死亡区(TDZ)
    * `let`和`const`没有声明提升, 它们声明的变量在声明前是不能被访问的, 如果访问它们会导致引用错误
    * 当JavaScript引擎浏览一段块级并发现变量声明时, 它要么声明提升, 要么将声明放在TDZ, 访问TDZ中的变量将会导致运行时错误, 只有将这个变量移出TDZ, 当执行流经过了变量声明, 才可以安全使用
* 循环中的块级变量
    * 循环中的`let`声明
        * 在循环中使用`let`声明可以不用IIFE(即建即调)来的到想要的效果
        * 在`for (let i=0; i < 10; i++) {}`中, `let`声明在每次循环中都会创建一个新的i, 因此每个新创建的函数均独享它特有的i
        * 对于`for-in`和`for-of`也是如此也可以使用
        * 在循环中的行为与`let`的无声明提升没有必然联系
    * 循环中的`const`声明
        * 没有显式地禁止在循环里使用`const`, 但是当循环中试图改变它的值时, 循环将抛出警告
        * 在`for-in`和`for-of`循环中, const变量与let变量行为一致, 因为在每次循环中, 初始化操作都会创建一个新的变量, 而不是试图修改已有的变量
* 全局块级变量
    * 在全局环境里使用let和const并不常见, 可能会导致命名冲突, 因为全局对象有预定义的属性 
    * 使用块级变量声明定义的变量若与全局对象的属性名冲突会出错, 因为全局对象的属性可能是不可配置的
    * 块级变量不允许相同作用域内的标识符重定义, 想覆盖不可配置的全局对象的属性是不可以的
* 关于块级变量的最佳实践
    * 默认使用const, 而只在你确定某个变量需要被更改时使用let
* 总结
    * `let`和`const`块级变量为JavaScript引入了词法作用域
    * 声明不会被提升, 而仅仅存在于它们所被声明的块级里
    * 无法在声明之前调用它们, 试图在声明之前调用块级变量将会导致错误, 这是块级变量在TDZ中的表现
    * `let`和`const`, 在for-in和for-of的每次循环中, 都会创建新的变量, 创建于循环当中的函数可以访问循环进行时的那个变量, 而不是最后一次循环里的值
    * `let`在for循环中也是如此, 而const则会导致错误
    * 默认使用`const`而仅在确定一个变量的值需要更改时使用`let`, 可以保证代码基本的不变性, 阻止一些特定类型的错误  
