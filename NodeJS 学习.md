# NodeJS 学习
## 预备知识

###关于权限
1. 使用`sudo`命令运行 NodeJs
2. 使用`sudo chmod +s`运行
第一种方法更推荐，可保证只让当前有需要的 js 脚本提供 root 权限，后一种让 NodeJS 始终以 root 权限运行，不安全。

###模块化
在 NodeJS 中一般会拆分成不同的 js 文件，每个文件就是一个模块，文件路径就是模块名。
1. `requir` 函数可以用来加载其他的模块，模块名可以用绝对路径、相对路径或者文件名，其中`.js`的文件扩展名可省略。
2. `exports`对象是当前模块导出的对象，导出模块提供的公有方法和属性。其他模块通过`requir` 函数引入的就是`exports`导出的对象。
3.  `module`对象可访问当前模块的信息，主要用途是替换当前模块的导出对象。例如：把默认的`exports`对象换成`exports`一个函数。
4. 模块初始化，一个模块中的 js 代码仅在模块第一次被使用时执行一次，并初始化模块的导出对象，之后导出的对象会被重复利用。
5. 主模块，通过命令行参数传递给NodeJS以启动程序的模块被称为主模块。主模块负责调度组成整个程序的其它模块完成工作。

###二进制模块
使用C/C++编写的叫二进制模块。编译好的二进制模块除了文件扩展名是`.node`外，和JS模块的使用方式相同。二进制模块能使用操作系统提供的所有功能，但难以跨平台使用。

###模块路径解析规则
1. 内置模块，如果是	NodeJS 内置模块名称，则不做路径解析。
2. `node-modules`目录， NodeJS 定义的存放模块的目录。
3. `NODE_PATH`环境变量，允许指定额外的模块搜索路径，可以写多个， Linux 下用`:`分隔， Windows 下用`;`分隔。

###包

把多个子模块组成的大模块称做包，并把所有子模块放在同一个目录里。在组成一个包的所有子模块中，需要有一个入口模块，入口模块的导出对象被作为包的导出对象。

1. `index.js` 文件名为 `index.js`时，可以用模块所在目录的路径代替文件路径。
2. `package.json` 在包目录下创建`package.json`文件，在里面指定入口模块的路径，就可以像上一种方法一样的路径去引入包， NodeJS 会根据`package.json`找到入口模块。

###命令行程序

在 Linux 中，可以把 JS 文件当做 shell 脚本运行。

1. 在主模块的顶部加上`#! /usr/bin/env node`，shell脚本中`#!`注释被用来指定解析器，而 NodeJS 会忽略`#!`后的注释内容。
2. 用`chomod +x`给文件授权。
3. 在 PATH 环境变量中指定的目录下，创建一个软链文件`sudo ln -s /home/user/bin/node-echo.js /usr/local/bin/node-echo`。

###NPM
随同NodeJS一起安装的包管理工具。

1. 下载三方包。
	* 	最新版本 `npm install packageName`
	* 指定版本 `npm install packageName@version`
	* 在`package.json`中写入包名和版本，通过`npm install`批量安装 
2. 安装命令行程序	

	`npm install packageName -g`，其中-g 表示全局安装  
3. 发布代码

	注册帐号，运行`npm adduser`，搞定后，编辑`package.json`，加入 NPM 必需字段，在运行`npm publish`发布
	
```
{
    "name": "node-echo",           # 包名，在NPM服务器上须要保持唯一
    "version": "1.0.0",            # 当前版本号
    "dependencies": {              # 三方包依赖，需要指定包名和版本号
        "argv": "0.0.2"
      },
    "main": "./lib/echo.js",       # 入口模块位置
    "bin" : {
        "node-echo": "./bin/node-echo"      # 命令行程序名和主模块位置
    }
}
``` 	

4. 版本号

	版本号分为 `x.y.z`三位，表示主版本号、次版本号和补丁版本号

###总结
* NodeJS是一个JS脚本解析器。
* 终端下输入node命令可进入命令交互模式，可以用来测试JS代码片段。
* NodeJS使用CMD模块系统，主模块作为程序入口点，所有模块在执行过程中只初始化一次。
* 二进制模块虽然可选用的功能全，但难以跨平台使用。
* 编写代码前要先规划好目录结构。
* 稍大些的程序可以将代码拆分为多个模块管理，更大些的程序可以使用包来组织模块。
* 合理使用node_modules和NODE_PATH来解耦包的使用方式和物理路径。
* 使用NPM可以看到实现了各种功能的包。

##文件操作-fs 模块

###常用 API 简述
####Buffer
全局构造函数`Buffer`来提供对二进制数据的操作。除了可以读取文件得到`Buffer`的实例外，还能够直接构造。可以与字符串相互转化，以下简述与字符串的异同:

* 可以用.length属性得到字节长度外，还可以用[index]方式读取指定位置的字节。
* 对字符串的任何修改得到的都是一个新字符串，原字符串保持不变。`Buffer`，可以用[index]方式直接修改某个位置的字节。对`.slice`方法返回的`Buffer`的修改会作用于原`Buffer`。
* 拷贝一份`Buffer`，得首先创建一个新的`Buffer`，并通过`.copy`方法把原`Buffer`中的数据复制过去。

####Stream
当内存中无法一次装下需要处理的数据时，需要用到数据流。 `Stream`基于事件机制工作，所有`Stream`的实例都继承于NodeJS提供的`EventEmitter`。

####File System
* 文件属性读写。其中常用的有`fs.stat`、`fs.chmod`、`fs.chown`等等。
* 文件内容读写。其中常用的有`fs.readFile`、`fs.readdir`、`fs.writeFile`、`fs.mkdir`等等。
* 底层文件操作。其中常用的有`fs.open`、`fs.read`、`fs.write`、`fs.close`等等。

####Path
简化路径相关操作，并提升代码可读性。

* `path.normalize`将传入的路径转换为标准路径。
* `path.join`将传入的多个路径拼接为标准路径。
* `path.extname`根据不同文件扩展名做不同操作。

###遍历目录
遍历目录是操作文件时的一个常见需求。

####递归算法
代码简洁，但由于每递归一次就产生一次函数调用，把递归算法转换为循环算法，可以减少函数调用次数。

####遍历算法
树状结构，在遍历时一般使用深度优先加先序遍历算法。深度优先，意味着到达一个节点后，首先接着遍历子节点而不是邻居节点。先序遍历，意味着首次到达了某节点就算遍历完成，而不是最后一次返回某节点才算数。

####同步遍历
以某个目录作为遍历的起点。遇到一个子目录时，就先接着遍历子目录。遇到一个文件时，就把文件的绝对路径传给回调函数。回调函数拿到文件路径后，就可以做各种判断和处理。

####异步遍历
如果读取目录或读取文件状态时使用的是异步API，目录遍历函数实现起来会有些复杂，但原理完全相同。

###文本编码
常用的文本编码有UTF8和GBK两种，并且UTF8文件还可能带有BOM。在读取不同编码的文本文件时，需要将文件内容转换为JS使用的UTF8编码字符串后才能正常处理。

####BOM的移除
BOM字符可以标记文件编码，但其本身却不属于文件内容的一部分，如果读取文本文件时不去掉BOM，在某些使用场景下就会有问题。

####GBK转UTF8
NodeJS支持在读取文本文件时，或者在`Buffer`转换为字符串时指定文本编码，但遗憾的是，GBK编码不在NodeJS自身支持范围内。因此，一般我们借助`iconv-lite`这个三方包来转换编码。

####单字节编码
不管大于0xEF的单个字节在单字节编码下被解析成什么乱码字符，使用同样的单字节编码保存这些乱码字符时，背后对应的字节保持不变。NodeJS中自带了一种binary编码可以用来实现这个方法。

###总结
* fs模块的同步API性能不好，但方便好用。
* 需要对文件读写做到字节级别的精细控制时，请使用fs模块的文件底层操作API。
* 不要使用拼接字符串的方式来处理路径，使用path模块。
* 掌握好目录遍历和文件编码处理技巧，很实用。

##网络操作

###常用 API 简述
####HTTP
模块提供两种使用方式：
* 作为服务端使用时，创建一个HTTP服务器，监听HTTP客户端请求并返回响应。
* 作为客户端使用时，发起一个HTTP客户端请求，获取服务端响应。

服务端模式下，首先需要使用`.createServer`方法创建一个服务器，然后调用`.listen`方法监听端口。之后，每当来了一个客户端请求，创建服务器时传入的回调函数就被调用一次。这是一种事件机制。

* HTTP请求本质上是一个数据流，由请求头和请求体组成。HTTP请求在发送给服务器时，可以认为是按照从头到尾的顺序一个字节一个字节地以数据流方式发送的。而http模块创建的HTTP服务器在接收到完整的请求头后，就会调用回调函数。在回调函数中，除了可以使用request对象访问请求头数据外，还能把request对象当作一个只读数据流来访问请求体数据。
* HTTP响应本质上也是一个数据流，同样由响应头和响应体组成。在回调函数中，除了可以使用response对象来写入响应头数据外，还能把response对象当作一个只写数据流来写入响应体数据。

客户端模式下，为了发起一个客户端HTTP请求，我们需要指定目标服务器的位置并发送请求头和请求体。

* `.request`方法创建了一个客户端，并指定请求目标和请求头数据。之后，就可以把request对象当作一个只写数据流来写入请求体数据和结束请求。另外，由于HTTP请求中GET请求是最常见的一种，并且不需要请求体，因此http模块也提供了以下便捷API。`http.get('http://www.example.com/', function (response) {});`
* 当客户端发送请求并接收到完整的服务端响应头时，就会调用回调函数。在回调函数中，除了可以使用response对象访问响应头数据外，还能把response对象当作一个只读数据流来访问响应体数据。

####HTTPS
https模块与http模块极为类似，区别在于https模块需要额外处理SSL证书。

* 与创建HTTP服务器相比，多了一个`options`对象，通过key和cert字段指定了HTTPS服务器使用的私钥和公钥。NodeJS支持SNI技术，可以根据HTTPS客户端请求使用的域名动态使用不同的证书，因此同一个HTTPS服务器可以使用多个域名提供服务。
* 在客户端模式下，发起一个HTTPS客户端请求与http模块几乎相同，如果目标服务器使用的SSL证书是自制的，不是从颁发机构购买的，默认情况下https模块会拒绝连接，提示说有证书安全问题。在options里加入rejectUnauthorized: false字段可以禁用对证书有效性的检查，从而允许https模块请求开发环境下使用自制证书的HTTPS服务器。

####URL
处理HTTP请求时url模块使用率超高，因为该模块允许解析URL、生成URL，以及拼接URL。可以使用`.parse`方法来将一个URL字符串转换为URL对象。传给`.parse`方法的不一定要是一个完整的URL，例如在HTTP服务器回调函数中，`request.url`不包含协议头和域名，但同样可以用`.parse`方法解析。`format`方法允许将一个URL对象转换为URL字符串，`.resolve`方法可以用于拼接URL。

```                           href
 -----------------------------------------------------------------
                            host              path
                      --------------- ----------------------------
 http: // user:pass @ host.com : 8080 /p/a/t/h ?query=string #hash
 -----    ---------   --------   ---- -------- ------------- -----
protocol     auth     hostname   port pathname     search     hash
                                                ------------
                                                   query
```

####Zlib
`zlib`模块提供了数据压缩和解压的功能。当我们处理HTTP请求和响应时，可能需要用到这个模块。

####Net
`net`模块可用于创建Socket服务器或Socket客户端。

	
	问： 为什么通过headers对象访问到的HTTP请求头或响应头字段不是驼峰的？
	答： 从规范上讲，HTTP请求头和响应头字段都应该是驼峰的。但现实是残酷的，不是每个HTTP服务端或客户端程序都严格遵循规范，所以NodeJS在处理从别的客户端或服务端收到的头字段时，都统一地转换为了小写字母格式，以便开发者能使用统一的方式来访问头字段，例如headers['content-length']。
	
	问： 为什么http模块创建的HTTP服务器返回的响应是chunked传输方式的？
	答： 因为默认情况下，使用.writeHead方法写入响应头后，允许使用.write方法写入任意长度的响应体数据，并使用.end方法结束一个响应。由于响应体数据长度不确定，因此NodeJS自动在响应头里添加了Transfer-Encoding: chunked字段，并采用chunked传输方式。但是当响应体数据长度确定时，可使用.writeHead方法在响应头里加上Content-Length字段，这样做之后NodeJS就不会自动添加Transfer-Encoding字段和使用chunked传输方式。
	
	问： 为什么使用http模块发起HTTP客户端请求时，有时候会发生socket hang up错误？
	答： 发起客户端HTTP请求前需要先创建一个客户端。http模块提供了一个全局客户端http.globalAgent，可以让我们使用.request或.get方法时不用手动创建客户端。但是全局客户端默认只允许5个并发Socket连接，当某一个时刻HTTP客户端请求创建过多，超过这个数字时，就会发生socket hang up错误。解决方法也很简单，通过http.globalAgent.maxSockets属性把这个数字改大些即可。另外，https模块遇到这个问题时也一样通过https.globalAgent.maxSockets属性来处理。

###总结
* http和https模块支持服务端模式和客户端模式两种使用方式。
* request和response对象除了用于读写头数据外，都可以当作数据流来操作。
* `url.parse`方法加上`request.url`属性是处理HTTP请求时的固定搭配。
* 使用zlib模块可以减少使用HTTP协议时的数据传输量。
* 通过net模块的Socket服务器与客户端可对HTTP协议做底层操作。

##进程管理

###常用 API 简述

####Process
任何一个进程都有启动进程时使用的命令行参数，有标准输入标准输出，有运行权限，有运行环境和运行状态。在NodeJS中，可以通过`process`对象感知和控制NodeJS自身进程的方方面面。另外需要注意的是，`process`不是内置模块，而是一个全局对象，因此在任何地方都可以直接使用。

####Child Process
使用`child_process`模块可以创建和控制子进程。该模块提供的API中最核心的是`.spawn`，其余API都是针对特定使用场景对它的进一步封装，算是一种语法糖。

####Cluster
`cluster`模块是对`child_process`模块的进一步封装，专用于解决单进程NodeJS Web服务器无法充分利用多核CPU的问题。使用该模块可以简化多进程服务器程序的开发，让每个核上运行一个工作进程，并统一通过主进程监听端口和分发请求。

###应用场景

####如何获取命令行参数

在NodeJS中可以通过process.argv获取命令行参数。但是比较意外的是，node执行程序路径和主模块文件路径固定占据了argv[0]和argv[1]两个位置，而第一个命令行参数从argv[2]开始。

####如何退出程序

通常一个程序做完所有事情后就正常退出了，这时程序的退出状态码为0。或者一个程序运行时发生了异常后就挂了，这时程序的退出状态码不等于0。如果我们在代码中捕获了某个异常，但是觉得程序不应该继续运行下去，需要立即退出，并且需要把退出状态码设置为指定数字。

####如何控制输入输出

NodeJS程序的标准输入流（stdin）、一个标准输出流（stdout）、一个标准错误流（stderr）分别对应`process.stdin`、`process.stdout`和`process.stderr`，第一个是只读数据流，后边两个是只写数据流，对它们的操作按照对数据流的操作方式即可。

####如何降权

在Linux系统下，我们知道需要使用root权限才能监听1024以下端口。但是一旦完成端口监听后，继续让程序运行在root权限下存在安全隐患，因此最好能把权限降下来。

1. 如果是通过sudo获取root权限的，运行程序的用户的UID和GID保存在环境变量SUDO_UID和SUDO_GID里边。如果是通过chmod +s方式获取root权限的，运行程序的用户的UID和GID可直接通过process.getuid和process.getgid方法获取。
2. process.setuid和process.setgid方法只接受number类型的参数。
3. 降权时必须先降GID再降UID，否则顺序反过来的话就没权限更改程序的GID了。

####如何创建子进程

可以使用`.spawn(exec, args, options)`方法。第一个参数是执行文件路径，可以是执行文件的相对或绝对路径，也可以是根据PATH环境变量能找到的执行文件名。第二个参数中，数组中的每个成员都按顺序对应一个命令行参数。第三个参数可选，用于配置子进程的执行环境与行为。

###小结

本章介绍了使用NodeJS管理进程时需要的API以及主要的应用场景，总结起来有以下几点：

* 使用process对象管理自身。
* 使用child_process模块创建和管理子进程。

##异步编程

###回调

在代码中，异步编程的直接体现就是回调。异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。3

