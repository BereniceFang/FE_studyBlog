高性能JavaScript笔记

# 加载和运行

* JavaScript阻塞特征是指当JavaScript运行时其他的事情不能被浏览器处理
  * 无论是内联还是外部文件, 页面下载和解析都会停下, 等待脚本处理完成才能继续
  * 使用src加载js时, 浏览器首先要下载外部文件的代码, 然后解析并运行, 这期间页面解析和用户交互是完全被阻塞的
  * 脚本位置
    * 浏览器在遇到`<body>`之前, 不会渲染页面的任何部分, 所以把js放在body之前引入会导致打开后首先显示为空白页的问题
    * 解决脚本阻塞其他页面资源的下载过程, 推荐方法是把`<script>`标签放在body的底部
  * 成组脚本
    * 每个HTTP请求都会有额外的性能负担, 所以要减少引用外部脚本文件的数量, 可以通过打包工具, 将多个JavaScript文件整合成一个文件,用一个`<script>`标签就可以加载他们
  * 非阻塞脚本
    * 一个大的js文件, 虽然只产生一次http请求, 但是会锁定浏览器一大段时间, 所以要向页面中逐步添加js
    * 等页面加载完成之后, 也就是window的load事件发出后再开始加载js代码
    * 延期脚本
      * 可以用defer属性, 带有defer属性的script标签可以放到文档的任何位置, 对应的文件将在标签被解析时下载, 但不会立即执行, 要等到DOM加载完成(onload事件被调用之前)才执行, 所以不会阻塞浏览器的其他处理过程
    * 动态脚本元素
      * 修改dom节点, 添加script标签加载js文件, 会在元素添加到页面之后立刻开始下载, 返回的代码通常会立即执行
      * 容易带来问题, 需要跟踪脚本下载完成并准备妥当的情况, 可以通过让动态添加的script节点发出事件来获得消息
        * IE支持另一种方式, 发出一个readystatechange事件, script标签有一个readyState属性, 有五个值: uninitialized loading loaded interactive complete
        * 在readystatechange事件中检查这两种状态, 出现其中一种的时候, 删除readystatechange事件, 防止再被处理
      * 动态加载是非阻塞js下载中最常用的模式, 可以跨浏览器
    * XHR 脚本注入
      * 创建一个XHR对象, 然后下载js文件, 用动态script元素把js代码注入页面
      * 具体过程: 向服务器发送一个获取js文件的get请求; onreadystatechange事件处理函数检查readyState是不是4, 检查HTTP状态码是不是有效, 如果收到有效的响应, 就创建一个新的script标签, 文本属性设置为接收到的responseText
      * 优势在于代码不受标签约束, 下载后不会自动执行可以推迟执行
      * 劣势在于js文件必须与页面放在同一个域内, 不能从CDN下载, 大型网页不适宜这种方式
    * 推荐的非阻塞模式
      * 分两个步骤:
        1. 动态加载js所需代码, 然后加载页面初始化所需的其他部分, 这部分js尽量小, 最好只包含loadScript函数
        2. 初始代码准备好之后, 用它加载其余的js
      * 放置在body的闭标签之前
      * 或者把loadScript函数嵌在页面中, 避免http请求
  * 一些库的简介
    * YUI
      * 思想: 用很小的初始代码, 下载其余的功能代码




