高性能JavaScript笔记

# 加载和运行

* JavaScript阻塞特征是指当JavaScript运行时其他的事情不能被浏览器处理
  * 无论是内联还是外部文件, 页面下载和解析都会停下, 等待脚本处理完成才能继续
  * 使用src加载js时, 浏览器首先要下载外部文件的代码, 然后解析并运行, 这期间页面解析和用户交互是完全被阻塞的
  * 脚本位置
    * 浏览器在遇到`<body>`之前, 不会渲染页面的任何部分, 所以把js放在body之前引入会导致打开后首先显示为空白页的问题
    * 解决脚本阻塞其他页面资源的下载过程, 推荐方法是把`<script>`标签放在body的底部
  * 成组脚本
    * 每个HTTP请求都会有额外的性能负担, 所以要减少引用外部脚本文件的数量, 可以通过打包工具, 将多个JavaScript文件整合成一个文件,用一个`<script>`标签就可以加载他们
  * 非阻塞脚本
    * 一个大的js文件, 虽然只产生一次http请求, 但是会锁定浏览器一大段时间, 所以要向页面中逐步添加js
    * 等页面加载完成之后, 也就是window的load事件发出后再开始加载js代码
    * 延期脚本
      * 可以用defer属性, 带有defer属性的script标签可以放到文档的任何位置, 对应的文件将在标签被解析时下载, 但不会立即执行, 要等到DOM加载完成(onload事件被调用之前)才执行, 所以不会阻塞浏览器的其他处理过程
    * 动态脚本元素
      * 修改dom节点, 添加script标签加载js文件, 会在元素添加到页面之后立刻开始下载, 返回的代码通常会立即执行
      * 容易带来问题, 需要跟踪脚本下载完成并准备妥当的情况, 可以通过让动态添加的script节点发出事件来获得消息
        * IE支持另一种方式, 发出一个readystatechange事件, script标签有一个readyState属性, 有五个值: uninitialized loading loaded interactive complete
        * 在readystatechange事件中检查这两种状态, 出现其中一种的时候, 删除readystatechange事件, 防止再被处理
      * 动态加载是非阻塞js下载中最常用的模式, 可以跨浏览器
    * XHR 脚本注入
      * 创建一个XHR对象, 然后下载js文件, 用动态script元素把js代码注入页面
      * 具体过程: 向服务器发送一个获取js文件的get请求; onreadystatechange事件处理函数检查readyState是不是4, 检查HTTP状态码是不是有效, 如果收到有效的响应, 就创建一个新的script标签, 文本属性设置为接收到的responseText
      * 优势在于代码不受标签约束, 下载后不会自动执行可以推迟执行
      * 劣势在于js文件必须与页面放在同一个域内, 不能从CDN下载, 大型网页不适宜这种方式
    * 推荐的非阻塞模式
      * 分两个步骤:
        1. 动态加载js所需代码, 然后加载页面初始化所需的其他部分, 这部分js尽量小, 最好只包含loadScript函数
        2. 初始代码准备好之后, 用它加载其余的js
      * 放置在body的闭标签之前
      * 或者把loadScript函数嵌在页面中, 避免http请求
  * 一些库的简介
    * YUI
      * 思想: 用很小的初始代码, 下载其余的功能代码
    * LazyLoad
      * 传递一个url队列给它, 可以下载多个js文件, 并保证顺序执行
      * 尽可能减少文件数量, 因为每次下载是单独的http请求, 所有文件下载并执行之后才会运行回调函数
    * LABjs
      * `$LAB.scipt()`下载一个js文件, `$LAB.wait()`用于指出一个等到文件下载完成并运行程之后才会被调用的函数
      * 支持链式调用, 每个函数返回一个指向$LAB的对象, 要下载多个就链式调用另一个`$LAB.script()`
      * 可以管理依赖关系, 不会像正常的scipt标签一样按顺序执行, 可以通过`wait()`函数来指定执行顺序
    * requirjs *补充*
	* seajs *补充*
## 总结
    * js代码执行阻塞浏览器处理过程, 有几种方法可以减少js对性能的影响
	    1. 把所有的`<script>`放在页面的底部, `</body>`上方, 可以保证页面在脚本运行之前完成解析
	    2. 成组打包, `<script>`越少加载速度越快, 无论外部还是内联都一样
	    3. 非阻塞方式下载js
	* `<script>`标签添加defer属性
	* 动态创建`<script>` 元素, 用它下载并执行代码
	* 用xhr对象下载代码并注入到页面中



# 数据访问

* js中有四中基本的数据存储位置:
  1. 直接量: 仅代表自己, 不存储于特定位置, 包括: 字符串 数字 布尔值 对象 数组 函数 正则表达式 具有特殊意义的空值 未定义
  2. 变量: 用var创建用于存储数据值
  3. 数组项: 有数字索引, 存储一个js数组对象
  4. 对象成员: 有字符串索引, 存储一个js对象
* 直接量和局部变量的访问速度要快于数组洋河对象成员, 所以要尽量使用直接量和局部变量, 限制另外两种的使用
* 管理作用域
  * 作用域链和标识符解析
    * 每一个函数都被表示为对象, 是一个函数实例
    * 内部`[[Scope]]`属性包含一个函数被创建的作用域中对象的集合, 这个集合就是作用域链, 作用域链的每一个对象都是可变对象以键值对形式存在


